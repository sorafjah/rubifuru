<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ルビふりお</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- 印刷設定 --- */
        @media print {
            body * { visibility: hidden; }
            #preview-container, #preview-container * { visibility: visible; }
            #preview-container {
                position: absolute;
                left: 0; top: 0; width: 100%; margin: 0; padding: 0;
                box-shadow: none; background: white;
            }
            .page-a4 {
                box-shadow: none !important; margin: 0 !important;
                width: 100% !important; height: auto !important;
            }
            ruby { ruby-position: over; }
        }

        /* --- プレビュー基本 --- */
        .preview-content {
            font-family: "BIZ UDPGothic", "BIZ UDGothic", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Meiryo", "Yu Gothic", sans-serif;
            line-height: 2.0;
            overflow-wrap: break-word;
            font-size: 12pt;
        }

        /* --- 用紙設定 --- */
        .page-a4 {
            width: 210mm; min-height: 297mm; padding: 20mm; margin: 0 auto;
            background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); box-sizing: border-box;
        }
        .page-hp {
            width: 100%; padding: 2rem; background: white; min-height: 100%;
        }

        /* --- ルビ編集用UI --- */
        ruby {
            display: inline-ruby;
            position: relative;
            cursor: pointer;
            border-radius: 4px;
            background-color: transparent;
            border-bottom: 1px dotted #ccc;
        }
        ruby:hover { background-color: #e0f2fe; }
        ruby.editing-active {
            background-color: #fce7f3; outline: 2px solid #ec4899; z-index: 10;
        }
        rt {
            display: ruby-text; font-size: 0.5em; line-height: 1;
            text-align: center; color: #555; user-select: none;
        }

        #html-editor { font-family: monospace; white-space: pre-wrap; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- ヘッダー -->
    <header class="bg-white shadow-sm z-10 p-3 flex justify-between items-center shrink-0">
        <h1 class="text-xl font-bold text-gray-700">ルビふりお</h1>
        <div class="flex gap-2">
            <button onclick="copyHtml()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-1.5 rounded text-sm transition">
                <i class="fas fa-code mr-1"></i> HTMLコピー
            </button>
            <button onclick="window.print()" class="bg-gray-700 hover:bg-gray-800 text-white px-4 py-1.5 rounded text-sm transition">
                <i class="fas fa-print mr-1"></i> 印刷
            </button>
        </div>
    </header>

    <!-- ツールバー -->
    <div class="bg-white border-b border-gray-200 p-2 flex flex-wrap gap-3 items-center shrink-0 text-sm">
        
        <!-- レイアウト -->
        <div class="flex items-center border-r pr-3 gap-2">
            <span class="text-gray-500 text-xs font-bold uppercase">レイアウト</span>
            <select id="layout-select" onchange="changeLayout()" class="border border-gray-300 rounded p-1">
                <option value="hp">HP用 (Web)</option>
                <option value="a4">A4印刷用</option>
            </select>
        </div>

        <!-- サイズ -->
        <div class="flex items-center border-r pr-3 gap-2">
            <span class="text-gray-500 text-xs font-bold uppercase">基本サイズ</span>
            <div class="flex items-center">
                <input type="number" id="base-font-size" value="12" min="6" max="72" class="w-14 border border-gray-300 rounded p-1 text-center" onchange="updateBaseFontSize()">
                <span class="ml-1 text-gray-600 text-xs">pt</span>
                <div class="flex flex-col ml-1 gap-0.5">
                    <button onclick="stepFontSize(1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▲</button>
                    <button onclick="stepFontSize(-1)" class="bg-gray-200 hover:bg-gray-300 px-1 rounded text-[10px] leading-none">▼</button>
                </div>
            </div>
        </div>

        <!-- 装飾ボタン群 -->
        <div class="flex items-center border-r pr-3 gap-1">
            <!-- フォント選択 -->
            <select id="font-family-select" onchange="wrapFontFamily(this.value); this.value='';" class="border border-gray-300 rounded p-1 w-24 mr-1 text-xs" title="選択部分のフォント変更">
                <option value="" disabled selected>フォント</option>
                <option value="">デフォルト(UD)</option>
                <option value="'UD Digi Kyokasho', 'YuKyokasho', 'Kaisho', serif">教科書体</option>
                <option value="'HiraMinProN-W3', 'YuMincho', 'MS PMincho', serif">明朝体</option>
                <option value="'Hiragino Kaku Gothic ProN', 'YuGothic', 'MS PGothic', sans-serif">ゴシック</option>
                <option value="'Hiragino Maru Gothic ProN', 'HGMaruGothicMPRO', 'Rounded Mplus 1c', sans-serif">丸ゴシック</option>
            </select>

            <button onclick="wrapSelection('b')" class="p-1.5 hover:bg-gray-100 rounded" title="太字"><i class="fas fa-bold"></i></button>
            <button onclick="wrapSelection('u')" class="p-1.5 hover:bg-gray-100 rounded" title="下線"><i class="fas fa-underline"></i></button>
            <button onclick="wrapColor('red')" class="p-1.5 hover:bg-gray-100 rounded text-red-500" title="赤文字"><i class="fas fa-font"></i></button>
            <button onclick="wrapFontSize()" class="p-1.5 hover:bg-gray-100 rounded" title="部分サイズ変更"><i class="fas fa-text-height"></i></button>
        </div>

        <div class="flex items-center gap-2 ml-auto">
            <a href="https://gemini.google.com/gem/1aQXlT177ks4j2LLC5ooZCyZV3xKGBIlx?usp=sharing" target="_blank" class="text-xs bg-indigo-50 text-indigo-700 border border-indigo-200 px-3 py-1 rounded hover:bg-indigo-100 transition flex items-center shadow-sm">
                <i class="fas fa-external-link-alt mr-2"></i> ルビを付けるGemを開く
            </a>
        </div>
    </div>

    <!-- メインエリア -->
    <div class="flex flex-1 overflow-hidden">
        <!-- エディタ -->
        <div class="w-1/2 flex flex-col border-r border-gray-300 bg-gray-50">
            <div class="p-2 bg-gray-100 border-b text-xs font-bold text-gray-500 flex justify-between">
                <span>HTMLソース入力</span>
                <span class="text-gray-400">Geminiで作ったコードを貼り付け</span>
            </div>
            <textarea id="html-editor" 
                class="flex-1 w-full p-4 resize-none focus:outline-none focus:ring-2 focus:ring-blue-300 text-gray-800 text-sm leading-relaxed font-mono"
                placeholder="<!-- ここにGemで生成したHTMLを貼り付けてください -->&#13;&#10;<ruby>漢字<rt>かんじ</rt></ruby>..."
                oninput="updatePreview()"></textarea>
        </div>
        <!-- プレビュー -->
        <div class="w-1/2 flex flex-col bg-gray-200 overflow-y-auto" id="preview-scroller">
            <div class="p-2 sticky top-0 bg-gray-200/90 backdrop-blur z-10 text-xs font-bold text-gray-500 border-b border-gray-300 flex justify-between">
                <span>プレビュー (クリックでルビ修正 / 選択してボタンで装飾)</span>
            </div>
            <div class="flex justify-center p-4 min-h-full">
                <!-- プレビュー本体 -->
                <div id="preview-container" class="page-hp preview-content"></div>
            </div>
        </div>
    </div>

    <!-- ルビ編集モーダル -->
    <div id="ruby-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 w-96 shadow-xl relative">
            <div class="flex justify-between items-center mb-4">
                <h3 class="font-bold text-lg text-gray-700"><i class="fas fa-pen mr-2"></i>ルビ修正</h3>
                <span class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded">Enterで次へ</span>
            </div>
            <div class="flex gap-4 mb-6 items-end">
                <div class="flex-1">
                    <label class="block text-xs text-gray-400 mb-1">漢字</label>
                    <div id="modal-kanji-display" class="text-2xl font-bold text-center bg-gray-100 p-2 rounded text-gray-800"></div>
                </div>
                <div class="flex-1">
                    <label class="block text-xs text-blue-500 font-bold mb-1">ふりがな</label>
                    <input type="text" id="modal-ruby" class="w-full text-xl border-b-2 border-blue-500 p-2 focus:outline-none bg-transparent text-center" placeholder="読み" autocomplete="off">
                </div>
            </div>
            <div class="flex justify-between gap-2 mb-4">
                <button onclick="navigateRuby(-1)" class="flex-1 py-1 px-2 text-sm bg-gray-100 hover:bg-gray-200 rounded text-gray-600">
                    <i class="fas fa-chevron-left mr-1"></i> 前へ
                </button>
                <button onclick="navigateRuby(1)" class="flex-1 py-1 px-2 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded font-bold">
                    保存して次へ (Enter) <i class="fas fa-chevron-right ml-1"></i>
                </button>
            </div>
            <div class="flex justify-end pt-4 border-t gap-3">
                <button onclick="closeRubyModal()" class="text-gray-400 hover:text-gray-600 text-sm">閉じる</button>
                <button onclick="removeRubyTag()" class="text-red-400 hover:text-red-600 text-sm">ルビ解除</button>
            </div>
        </div>
    </div>

    <script>
        const editor = document.getElementById('html-editor');
        const preview = document.getElementById('preview-container');
        const baseFontSizeInput = document.getElementById('base-font-size');
        let currentTargetRuby = null;

        window.addEventListener('DOMContentLoaded', () => {
            updateBaseFontSize();
            updatePreview();
        });

        function updatePreview() {
            const rawText = editor.value;
            const htmlContent = rawText.replace(/\n/g, '<br>');
            preview.innerHTML = htmlContent;
            attachRubyClickEvents();
        }

        function updateBaseFontSize() {
            let size = parseInt(baseFontSizeInput.value) || 12;
            preview.style.fontSize = size + 'pt';
        }
        function stepFontSize(amount) {
            let current = parseInt(baseFontSizeInput.value) || 12;
            let next = Math.max(6, current + amount);
            baseFontSizeInput.value = next;
            updateBaseFontSize();
        }
        function changeLayout() {
            const type = document.getElementById('layout-select').value;
            preview.className = `preview-content ${type === 'a4' ? 'page-a4' : 'page-hp'}`;
        }

        // --- 装飾機能 (プレビュー選択対応版) ---

        // 選択範囲がエディタかプレビューかを判定し、タグを適用する
        function applyStyleToSelection(startTag, endTag) {
            const selection = window.getSelection();
            
            // プレビュー側が選択されている場合
            if (selection.rangeCount > 0 && preview.contains(selection.anchorNode)) {
                applyStyleToPreview(startTag, endTag, selection);
            } 
            // それ以外（エディタ側）の場合
            else {
                insertTagToEditor(startTag, endTag);
            }
        }

        // プレビューの選択範囲にスタイルを適用して、ソースに反映させる
        function applyStyleToPreview(startTag, endTag, selection) {
            if (selection.isCollapsed) return;

            // 簡易的な実装: HTMLタグを解析せず、選択範囲をspanで囲む
            // 注意: 複雑なネストやルビを跨ぐ選択だとうまくいかない場合がありますが、
            // このツールとしては「部分的な文字装飾」が主目的なので許容します。
            
            const range = selection.getRangeAt(0);
            
            // 新しい要素を作成（タグの中身を解析してstyle属性などを作る）
            // ここでは簡易的に、startTagが <span style="..."> 前提で処理
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = startTag + 'dummy' + endTag;
            const wrapper = tempDiv.firstElementChild; // 作成されたタグ (例: span)
            
            if (wrapper) {
                // 選択範囲を抽出してラップする
                try {
                    // Rangeの内容をラップする
                    const content = range.extractContents();
                    wrapper.innerHTML = ""; // dummyを消す
                    wrapper.appendChild(content);
                    range.insertNode(wrapper);
                    
                    // 変更されたプレビューのHTMLをエディタに書き戻す
                    syncPreviewToEditor();
                    
                    // 選択解除
                    selection.removeAllRanges();
                } catch (e) {
                    console.error("Selection wrap failed:", e);
                    alert("その選択範囲には適用できません（タグを跨いでいる可能性があります）");
                }
            }
        }

        function insertTagToEditor(startTag, endTag) {
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const text = editor.value;
            editor.value = text.substring(0, start) + startTag + text.substring(start, end) + endTag + text.substring(end);
            editor.focus();
            editor.selectionStart = start + startTag.length;
            editor.selectionEnd = end + startTag.length;
            updatePreview();
        }

        // --- 各装飾ボタンの呼び出し ---
        function wrapSelection(tag) { 
            applyStyleToSelection(`<${tag}>`, `</${tag}>`); 
        }
        function wrapColor(color) { 
            applyStyleToSelection(`<span style="color:${color}">`, `</span>`); 
        }
        function wrapFontSize() {
            const size = prompt("サイズ (例: 20pt, 1.5em)", "20pt");
            if(size) applyStyleToSelection(`<span style="font-size:${size}">`, `</span>`);
        }
        function wrapFontFamily(font) {
            if(!font) return; // デフォルト選択時は何もしない（あるいはstyle削除ロジックが必要だが簡易的に追加のみ）
            // デフォルトに戻す場合(valueが空文字)は、span style="font-family..." を削除するのが理想だが、
            // 簡易的に「デフォルトの場合はタグをつけない」挙動にする
            if (font === "") return;
            applyStyleToSelection(`<span style="font-family:${font}">`, `</span>`);
        }


        // --- ルビ機能 ---
        function attachRubyClickEvents() {
            preview.querySelectorAll('ruby').forEach(ruby => {
                ruby.onclick = (e) => { e.stopPropagation(); openRubyModal(ruby); };
                ruby.title = "修正する";
            });
        }

        const modal = document.getElementById('ruby-modal');
        const modalKanjiDisplay = document.getElementById('modal-kanji-display');
        const modalRuby = document.getElementById('modal-ruby');

        function openRubyModal(rubyElement) {
            if(currentTargetRuby) currentTargetRuby.classList.remove('editing-active');
            currentTargetRuby = rubyElement;
            currentTargetRuby.classList.add('editing-active');

            let kanjiText = "";
            rubyElement.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) kanjiText += node.textContent;
            });
            const rt = rubyElement.querySelector('rt');
            modalKanjiDisplay.textContent = kanjiText;
            modalRuby.value = rt ? rt.textContent : "";
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            modalRuby.focus();
        }

        function closeRubyModal() {
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            if(currentTargetRuby) {
                currentTargetRuby.classList.remove('editing-active');
                currentTargetRuby = null;
            }
        }

        function saveRubyAndStay() {
            if (!currentTargetRuby) return;
            const rt = currentTargetRuby.querySelector('rt');
            if (rt) rt.textContent = modalRuby.value;
            syncPreviewToEditor();
        }

        function navigateRuby(direction) {
            if(!currentTargetRuby) return;
            saveRubyAndStay();
            const allRubies = Array.from(preview.querySelectorAll('ruby'));
            const nextIndex = allRubies.indexOf(currentTargetRuby) + direction;
            if (nextIndex >= 0 && nextIndex < allRubies.length) {
                openRubyModal(allRubies[nextIndex]);
            } else {
                closeRubyModal();
            }
        }

        function removeRubyTag() {
            if (!currentTargetRuby) return;
            let kanjiText = "";
            currentTargetRuby.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) kanjiText += node.textContent;
            });
            currentTargetRuby.parentNode.replaceChild(document.createTextNode(kanjiText), currentTargetRuby);
            syncPreviewToEditor();
            closeRubyModal();
        }

        function syncPreviewToEditor() {
            // プレビューのDOMからHTMLを取得し、改行コードを復元してエディタに戻す
            let html = preview.innerHTML;
            // <br>を改行コードに置換
            html = html.replace(/<br\s*\/?>/gi, '\n');
            editor.value = html;
        }

        function copyHtml() {
            navigator.clipboard.writeText(editor.value).then(() => alert('コピーしました'));
        }

        modal.addEventListener('click', (e) => { if (e.target === modal) closeRubyModal(); });
        modalRuby.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); navigateRuby(1); }
        });
    </script>
</body>
</html>
